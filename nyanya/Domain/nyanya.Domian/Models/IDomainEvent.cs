using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using JetBrains.Annotations;

namespace Domian.Models
{
    internal interface IDomainEvent
    {
        /// <summary>
        /// 表示事件发生的时间的时间戳
        /// </summary>
        DateTime OccurredOn { get; }

        // 使用领域事件来捕获发生在领域中的一些事情。将领域中所发生的活动建模成一系列的离散事件。每个事件都用
        // 领域对象来表示。领域时间是领域模型的组成部分。表示领域中所发生的事情。

        // “当……”
        // “如果发生……”
        // “当……的时候，请通知我”
        // “发生……时”

        // 当领域时间到达目的地之后——无论是本地系统还是外部系统——我们通常都将领域事件用于维护事件的一致性。这是有意而为之的，
        // 并且是根据设计而来的。这样可以消除两阶段提交（全局事务），还可以支持聚合原则。

        // 聚合原则：在单个事务中，只允许对一个聚合实例进行修改，由此产生的其他改变必须在单独的事务中完成。

        // 本地界限上下文中的其他聚合实例便可以通过领域事件的方式予以同步。另外，领域时间还可以用于使远程依赖系统与本地系统
        // 保持一致。本地系统和远程系统的解耦有助于提高双方协作服务的可伸缩性。

        // 除了事件的来源信息，如果订阅方还需要进行更多的操作，那么我们可以向事件中添加额外的状态和行为。这样，订阅方
        // 便不用再对聚合进行查询。

        // 领域事件往往是由聚合中的命令方法产生，同时也可能直接由客户方所发出的请求产生。

        // 领域事件应该设计成不变的，但是它们将拥有唯一标识，即使事件的唯一标识可以由一组属性来决定，最好的方式还是采用生成
        // 的唯一标识。

        // 领域事件将携带有限的命令参数和聚合状态，这些信息足以使作为订阅方的限界上下文做出相应的操作。
    }
}

/*
 * 消息设施的一致性
 *     对于最终一致性，我们至少需要在两种存储之间保持最终一致性：领域模型所使用的持久化存储和消息设施所使用的持久化存储。
 * 这样保证了在持久化领域模型时，相应的领域事件也总能够得以发布。如果这两者没有得到同步，有可能导致模型处于不正确的状态。
 *     保证领域模型存储和时间存储之间的一致性方式：
 *     1. 领域模型和消息设施共享持久化存储（比如，数据源）。在这种情况下，对模型的修改和对事件的提交发生在同一个本地事务中。
 *     这种方式的优点在于性能很高，而缺点在于消息系统的存储区域（比如数据库表）必须和领域模型位于同一个数据库中。当然，如果
 *     你的领域模型和消息机制不能共享持久化存储，这种方式便不合适了。
 *     2. 领域模型的持久化存储和消息持久化存储由全局的XA事务（两阶段提交）所控制。这种方式的优点在于模型和消息所使用的持久
 *     化存储可以分开；缺点在于全局事务需要额外的支持，但不见得所有的存储机制都支持全局事务。全局事务的成本是很高的，而性能
 *     却很差。有可能出现的情况是，要么领域模型存储不支持XA事务，要么消息存储不支持XA事务，要么两者都不支持。
 *     3. 在领域模型的持久化存储中，创建一个特殊的存储区域（比如一张数据库表），该区域用于存储领域时间。这便是一个事件存储
 *     （Event Store）。
 */